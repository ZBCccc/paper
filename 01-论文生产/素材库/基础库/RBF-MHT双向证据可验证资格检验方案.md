# RBF 保留 + MHT 承诺层：双向证据可验证资格检验方案（草案）

## 1. 目标与设计原则

- **目标**：在 Nomos 的 RBF 资格检验语义不变前提下，实现可验证执行。
- **核心原则**：`Positive` 与 `Negative` 都必须提交证据，不做单侧验证。
- **语义边界**：本方案约束的是 XSet/RBF 资格检验执行正确性，不单独解决 TSet 候选枚举完整性。

---

## 2. 攻击面与防护目标

### 2.1 主要恶意行为

1. **伪造拒绝（False Reject）**：本应通过却被伪报为不通过。
2. **伪造通过（False Accept）**：本应不通过却被伪报为通过。
3. **跳检（Skip Check）**：未检查全部地址即输出判定。
4. **地址替换（Address Substitution）**：把应检查地址换成其他地址。
5. **状态回放（Replay）**：使用旧版本 XSet 状态生成“看似有效”的证明。

### 2.2 本方案覆盖范围

- 覆盖：1-5（在 CRHF + 签名安全 + 版本检查前提下）。
- 不覆盖：TSet 漏候选、恶意 Gate-keeper、SSE 既有泄露面本体。

---

## 3. 数据结构：Merkle-ized XSet

设第 `t` 轮更新后的 RBF 位数组为 `B^(t) ∈ {0,1}^M`。

- **叶子定义**：
  - `L_i^(t) = H(0 || i || B^(t)[i])`
- **内部节点**：
  - `N = H(1 || N_left || N_right)`
- **根哈希**：
  - `R_t`
- **锚点签名**：
  - `σ_t = Sign_GK(t || R_t)`

客户端信任锚点为 `(t, R_t, σ_t)`，并维护本地最新版本号 `t*`。

---

## 4. 与 RBF 语义的绑定方式

Nomos 保留：

- 插入/更新侧：对每个关系写入 `ℓ` 个地址。
- 查询侧：检查 `k` 个地址（`k < ℓ`）。
- 判定规则：若存在任一 `0`，则该关系不通过；全 `1` 才通过。

关键点是把“应检查哪 `k` 个地址”绑定进令牌，定义：

- `A_{j,id}^{(t,ν)} = AddrSet(x_{j,id}, ν)`，`|A_{j,id}^{(t,ν)}| = k`
- 其中 `ν` 是令牌随机量，`x_{j,id}` 是 `(w_j, id)` 的资格标签

这样客户端可独立重建地址集合，防止服务器换地址。

---

## 5. 双向证据协议

以下以查询 `Q = w_s ∧ w_2 ∧ ... ∧ w_m` 为例。

### 5.1 Setup/Update（承诺维护）

1. GK 按 Nomos 原流程更新 `TSet/XSet`。
2. 对受影响地址更新 Merkle 路径，得到新根 `R_t`。
3. 发布 `(t, R_t, σ_t)` 给授权客户端。

### 5.2 GenToken（地址绑定）

1. 令牌包含版本 `t` 与随机量 `ν`。
2. 地址集合生成规则固定公开，客户端可据此重建每个 `A_{j,id}^{(t,ν)}`。

### 5.3 Search-Prove（服务器输出）

服务器先由 `TSet` 得到 `Cand(w_s)`，再对每个 `(j,id)` 计算判定并给证据：

- **Positive 证据** `Proof^+_{j,id}`：
  - 对 `A_{j,id}^{(t,ν)}` 中全部 `k` 个地址返回 `(a,1,π_a)`。
- **Negative 证据** `Proof^-_{j,id}`：
  - 返回集合内至少一个 `0` 地址证明 `(a0,0,π_{a0})`，并声明 `a0 ∈ A_{j,id}^{(t,ν)}`。

服务器返回：

- `ρ = (Cand, Res, t, R_t, σ_t, Π_Q)`

其中 `Π_Q` 为所有 `(j,id)` 的证明集合。

### 5.4 Client-Verify（客户端校验）

1. 验签与版本：
   - 验证 `VfSig(pk_GK, t || R_t, σ_t)=1`
   - 检查 `t` 与本地最新版本一致（或按策略仅接受不回退版本）
2. 地址归属：
   - 重建 `A_{j,id}^{(t,ν)}`
   - 检查每个证明地址是否属于对应集合
3. 路径验证：
   - 验证每个 `(a,b,π_a)` 到同一根 `R_t`
4. 判定重算：
   - Positive：必须有 `k` 个地址且全为 `1`
   - Negative：至少一个地址为 `0`
5. 结果一致性：
   - 根据重算判定重构 `Res'`
   - 若 `Res' != Res` 或存在缺失证明则拒绝

---

## 6. 形式化安全目标（建议用于论文）

1. **Correctness**  
   诚实执行下，验证通过且输出与 Nomos 资格语义一致。

2. **Binding-Soundness**  
   对手让客户端接受“声明判定与承诺状态不一致”的概率可忽略。

3. **Freshness**  
   对手让客户端接受旧版本或混合版本证明的概率可忽略。

4. **Conditional-Completeness**  
   在 `Cand(w_s)` 完整返回前提下，对手无法隐匿应通过候选且不被检测。

---

## 7. 复杂度与开销

### 7.1 更新开销

- 单个关系更新触及 `ℓ` 个位地址。
- 承诺层新增哈希开销：`O(ℓ log M)`。

### 7.2 查询与证明开销

- 每个 `Positive (j,id)`：`k` 条路径证明。
- 每个 `Negative (j,id)`：至少 `1` 条路径证明。
- 单条路径大小与验证开销：`O(log M)`。

### 7.3 代价特征

- 相比“只做 Negative 证明”，双向证据显著提高可验证性闭合度。
- 主要额外成本来自 Positive 证明数量；可后续用多证明压缩优化。

---

## 8. 工程落地建议

1. **论文主线先用严格模式**：Positive/Negative 全量证据，先保证安全论证完整。
2. **实验再加优化模式**：例如 Positive 抽样验证或 Merkle multiproof，作为工程折中。
3. **实现细节固定化**：
   - 地址生成函数 `AddrSet` 固定且可复现；
   - 版本号单调，拒绝回退；
   - 证明格式定长化，减少侧信道。

---

## 9. 审稿风险与预防

- 风险 1：被质疑“只验证拒绝，不验证通过”。  
  - 预防：本文采用双向证据并给出一致性重算。
- 风险 2：被质疑“地址可替换”。  
  - 预防：令牌绑定 `ν`，客户端重建 `A_{j,id}` 并验证归属。
- 风险 3：被质疑“旧状态回放”。  
  - 预防：`(t,R_t,σ_t)` 锚点签名 + 版本一致性检查。
- 风险 4：被质疑“完整性不闭合”。  
  - 预防：明确条件完整性前提，TSet 完整性在后续章节单独处理。

---

**最后更新**：2026-02-22  
**标签**：SSE，Nomos，RBF，MHT，资格检验，可验证性
