# 嵌入式承诺地址绑定方案（草案）

## 1. 问题定位：位置盲化下的地址替换攻击

### 1.1 第二章 MHT 的能力边界

第二章在 XSet 上构建 QTree（Merkle-ized XSet），为每个 RBF 位地址提供认证路径。该机制保证：Server 声称的位值（0 或 1）与 QTree 根承诺下的真实位值一致。

但 MHT 的验证前提是：Client 知道哪些地址应该被验证。

### 1.2 位置盲化问题

在 Nomos 中，由于 OPRF 盲化设计：

- Client 不持有 $K_X$，无法自行计算 (w, id) 对应的 XSet 物理地址
- 这些地址由 Server 在搜索阶段从 Token 中恢复（通过 $\alpha$ 参数与 $\mathsf{xtoken}$ 计算 $\mathsf{xtag}$）
- Client 只知道 Token 的盲化形式，不知道最终的物理地址

这是 Nomos 隐私设计的固有特征，不是缺陷——它保证了 Client 不获知查询的物理访问模式。

### 1.3 地址替换攻击

攻击场景：

1. Server 收到 Token，计算出 id 对应的真实地址集合 {Addr_1, ..., Addr_k}
2. 真实地址上的位值全为 1（id 应通过资格检验）
3. Server 找到一个不属于该集合但位值为 0 的地址（如地址 999）
4. Server 返回地址 999 的合法 Merkle Proof，声称 id 不通过
5. Client 验证 Merkle Proof 有效（因为地址 999 确实在 QTree 中且位值确实为 0）
6. Client 错误地接受了"id 不通过"的判定

关键：Server 用"张冠李戴"的证据欺骗 Client。Merkle Proof 本身是合法的，但证明的地址不是 id 对应的地址。

### 1.4 与第二章的关系

- 第二章 QTree 提供"位值真实性"（bit value authenticity）
- 本章嵌入式承诺提供"地址正确性"（address correctness）
- 两者组合才构成完整的可验证资格检验

---

## 2. 核心思路：嵌入式承诺

### 2.1 设计直觉

GK 在 Update 阶段拥有所有密钥，能计算 (w, id) 对应的全部 k 个 XSet 地址。将这些地址的承诺嵌入 TSet 的加密 Payload 中，使 Client 在验证时能核对 Server 使用的地址是否属于 GK 确定的地址集合。

### 2.2 承诺构造

对每条 TSet 记录 (w, id)，GK 计算：

1. 该记录对应的 k 个 XSet 地址：$\{Addr_1, \ldots, Addr_k\}$
2. 地址承诺：$Cm = H(Addr_1 \| Addr_2 \| \cdots \| Addr_k)$（地址按确定性排序）
3. 扩展 TSet Payload：原始为 $E_{K_T}(\mathsf{id} \| \mathsf{xind})$，扩展为 $E_{K_T}(\mathsf{id} \| \mathsf{xind} \| Cm)$

承诺粒度：per-(w, id)，每条 TSet 记录嵌入该记录对应的 k 个 XSet 地址的承诺。

### 2.3 验证流程

当 Server 声称某候选 id 应被丢弃（Negative 判定）时：

1. Server 返回加密 Payload（含 Cm）
2. Server 返回某地址 $Addr_j$ 的 Merkle Proof（证明该地址位值为 0）
3. Server 提供"开封"信息：其余 k-1 个地址
4. Client 解密 Payload 得到 id 和 Cm
5. Client 用 Server 提供的全部 k 个地址重算哈希：$H(Addr_1 \| \cdots \| Addr_k) \stackrel{?}{=} Cm$
6. 若匹配，确认 $Addr_j$ 确实属于 GK 在更新阶段确定的地址集合
7. 再结合 Merkle Path 验证该地址位值确为 0

对 Positive 判定（id 通过资格检验）：

1. Server 返回加密 Payload（含 Cm）
2. Server 返回全部 k 个地址的 Merkle Proof（证明位值全为 1）
3. Client 解密得到 Cm，验证 k 个地址的哈希与 Cm 一致
4. 再验证每个地址的 Merkle Path

---

## 3. 协议流程

### 3.1 Update（承诺嵌入）

GK 对每条更新 (w, id, op)：

1. 按 Nomos 原流程计算 $\mathsf{xtag}_i = H(w)^{K_X[I(w)] \cdot F_p(K_Y, \mathsf{id} \| \mathsf{op}) \cdot i}$，$i \in [\ell]$
2. 计算查询侧将使用的 k 个地址（由 $\beta_1, \ldots, \beta_k$ 索引 $\ell$ 个投影位中的子集）
3. 计算承诺 $Cm = H(\mathsf{xtag}_{\beta_1} \| \cdots \| \mathsf{xtag}_{\beta_k})$
4. 将 Cm 嵌入 TSet 加密 Payload：$\mathsf{val} \leftarrow (\mathsf{id} \| \mathsf{op} \| Cm) \oplus H(w \| \mathsf{UpdateCnt}[w] \| 1)^{K_T[I(w)]}$

**注意**：$\beta_1, \ldots, \beta_k$ 在 Nomos 中是 GenToken 阶段由 GK 随机采样的。这意味着承诺必须在 GenToken 阶段生成，而非 Update 阶段。

### 3.2 关键设计决策：承诺生成时机

**问题**：在 Nomos 中，k 个采样位置 $\{\beta_i\}$ 是在 GenToken 阶段由 GK 随机选取的，每次查询不同。这意味着 Update 阶段 GK 不知道未来查询会采样哪 k 个位置。

**方案 A：Update 阶段承诺全部 ℓ 个地址**

- $Cm = H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell)$
- 开封时 Server 提供全部 ℓ 个地址
- 优点：承诺在 Update 阶段即可确定，与查询无关
- 缺点：暴露全部 ℓ 个地址给 Client（但 Client 已持有解密密钥，安全性可接受）

**方案 B：GenToken 阶段生成 per-query 承诺**

- GK 在 GenToken 时选定 $\{\beta_i\}$ 后，计算 $Cm = H(\mathsf{xtag}_{\beta_1} \| \cdots \| \mathsf{xtag}_{\beta_k})$
- 承诺通过令牌或安全信道传递给 Client
- 优点：只暴露 k 个地址
- 缺点：承诺不嵌入 TSet（因为 TSet 在 Update 阶段已写入），需要额外传输通道

**方案 C（推荐）：Update 阶段承诺全部 ℓ 个地址，查询侧验证子集归属**

- Update 阶段：$Cm = H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell)$，嵌入 TSet
- Search 阶段：Server 返回全部 ℓ 个地址作为开封
- Verify 阶段：Client 验证 $H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell) = Cm$，然后检查 Server 实际使用的 k 个地址是否为 ℓ 个地址中由 $\{\beta_i\}$ 索引的子集
- 优点：承诺在 Update 阶段确定，嵌入 TSet；Client 可验证地址归属
- 缺点：暴露全部 ℓ 个地址

**选择方案 C 的理由**：
1. 承诺嵌入 TSet 是本章的核心设计目标（"嵌入式"承诺）
2. ℓ 个地址的暴露不构成额外隐私风险——这些地址是 PRF 输出，不泄露关键词明文
3. Client 已持有解密 TSet Payload 的能力，地址信息的安全级别不高于 Payload 内容

### 3.3 Search-Prove（服务器输出）

对每个候选 (j, id)：

1. Server 解密 TSet Payload 得到 (id, op, Cm)
2. Server 计算全部 ℓ 个 xtag 地址
3. Server 在 QTree 上查询 k 个采样地址的位值
4. 生成判定与证据：
   - Positive：k 个地址的 Merkle Proof（全为 1）
   - Negative：至少一个 0 地址的 Merkle Proof
5. 返回：加密 Payload + 全部 ℓ 个地址（开封）+ Merkle Proof + 判定位

### 3.4 Client-Verify（客户端校验）

1. **版本与根验证**：验证 QTree 根与版本锚点一致
2. **承诺开封验证**：解密 Payload 得到 Cm，验证 $H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell) = Cm$
3. **地址归属验证**：检查 Server 使用的 k 个地址是否为 ℓ 个地址中由 $\{\beta_i\}$ 索引的子集
4. **Merkle 路径验证**：验证每个证明地址的位值与路径
5. **判定重算**：根据已验证的位值重算判定，与 Server 声明比对

---

## 4. 安全性目标

### 4.1 地址绑定健全性（Address Binding Soundness）

对任意 PPT 对手 $\mathcal{A}$，其使 Client 接受一个"证明地址不属于承诺地址集合"的响应的概率：

$$\Pr[\mathsf{Verify} = 1 \wedge \exists a \in \mathsf{Proof}: a \notin \{xtag_1, \ldots, xtag_\ell\}] \leq \mathsf{negl}(\lambda)$$

归约：若 Server 能构造一组地址 $\{xtag'_1, \ldots, xtag'_\ell\}$ 使得 $H(xtag'_1 \| \cdots \| xtag'_\ell) = Cm$ 但 $\{xtag'_i\} \neq \{xtag_i\}$，则构成 H 的碰撞。

### 4.2 与第二章安全性质的组合

- 第二章绑定健全性：Server 不能伪造位值 → 位值真实
- 本章地址绑定健全性：Server 不能替换地址 → 地址正确
- 组合效果：Server 在正确的地址上给出真实的位值 → 完整的可验证资格检验

---

## 5. 开销分析

### 5.1 存储开销

- 每条 TSet 记录增加一个 λ 比特的承诺值 Cm
- 总额外存储：$O(N \cdot \lambda)$，N 为 TSet 记录总数

### 5.2 通信开销

- 每个候选的开封信息：ℓ 个地址（每个 λ 比特）
- 额外通信：$O(|\mathsf{Cand}(w_s)| \cdot \ell \cdot \lambda)$

### 5.3 计算开销

- Client 验证：每个候选一次哈希（验证 Cm）+ 子集归属检查
- 额外计算：$O(|\mathsf{Cand}(w_s)| \cdot \ell)$

---

## 6. 待确认问题

1. **ℓ 个地址的排序规则**：需要确定性排序以保证承诺唯一性。建议按地址值的字典序排序。
2. **删除操作的处理**：当 (w, id) 被删除时，对应的 TSet 记录标记为 del，Cm 仍然有效（因为 XSet 地址不变，只是位值可能变化）。
3. **与 TSet 结果完整性的关系**：本章解决地址绑定，TSet 结果完整性（漏报/伪造/回放）是独立问题，可在后续章节或合并处理。

---

**最后更新**：2026-02-25
**标签**：SSE，Nomos，嵌入式承诺，地址绑定，位置盲化，可验证性
