# 论文研究流程

## 当前执行状态（基于 2026-02-25 更新）

1. 第一章绪论：主体完成，进入术语与引用精修阶段
2. 第二章机制（MHT 可验证资格检验）：正文初稿完成，证明与小结待精修
3. 第三章机制（嵌入式承诺地址绑定）：**初稿完成**（221 行，6 节，算法 5-7，定义 5，命题 5-6），进入精修阶段
4. 第四章实验：评估框架已列，参数与结果待填
5. 第五章结论：结构已建，正文待写

本文件用于约束后续写作顺序：先精修第三章与第二章的衔接（定义/命题编号、前向引用），再落地第四章实验，最后收束第五章。

## 研究问题与目标

### 问题定义

针对多用户多关键词对称可搜索加密场景，研究如何在泄露受限隐私保护模型下引入轻量可验证机制，使授权用户能够验证服务器在搜索流程中的关键步骤是否按协议执行，并检测搜索结果的完整性与正确性。

### 研究目标

1. **可验证资格检验**：使用默克尔哈希树替换布隆过滤器，实现可证明的资格检验
2. **搜索结果验证**：使用嵌入式承诺机制，将验证信息嵌入索引结构中
3. **性能优化**：保持原有的搜索效率，将验证开销控制在可接受范围内

---

## 研究内容与创新点

### 核心研究内容

1. **系统与威胁模型**：建立统一的符号体系和安全目标
2. **可验证资格检验**：基于默克尔哈希树的资格检验机制
3. **搜索结果验证**：基于嵌入式承诺的搜索结果正确性验证
4. **安全性与可验证性分析**：证明机制的安全性与正确性
5. **实验评估**：评估引入验证机制后的性能开销

### 创新点

#### 创新点一：基于默克尔哈希树的可验证资格检验机制（第二章）

**问题定位**：Nomos 的资格检验基于 RBF（Relaxed Bloom Filter），Server 在 XSet 位数组上执行成员测试并返回判定结果，但 Client 无法验证该判定是否忠实于 XSet 的真实状态。Server 可实施以下恶意行为：伪造拒绝（将应通过的候选报为不通过）、伪造通过（将不应通过的候选报为通过）、跳检（未检查全部采样地址即输出判定）。这些行为的根源在于：RBF 位数组是一个无认证承诺的裸数据结构，Server 对位值的声明不受任何密码学约束。

**机制设计**：在 XSet 位数组 $B^{(t)} \in \{0,1\}^M$ 上构建 QTree（Merkle-ized XSet）。叶节点定义为 $L_i^{(t)} = H(0 \| i \| B^{(t)}[i])$，内部节点按标准 Merkle 哈希树递归构建，根哈希 $R_t$ 由 GK 签名后发布为信任锚点 $(t, R_t, \sigma_t)$。该结构保留 Nomos 的 RBF 语义不变——更新侧对每个关系 $(w, \mathsf{id})$ 写入 $\ell$ 个地址，查询侧采样 $k$ 个地址（$k < \ell$）执行成员测试——在其上叠加认证承诺层。

**双向证据机制**：Server 的每次资格判定必须附带 Merkle 认证路径作为证据。Positive 判定要求提供全部 $k$ 个采样地址的认证路径且位值全为 1；Negative 判定要求提供至少一个位值为 0 的地址的认证路径。Client 通过验签确认根哈希 $R_t$ 的真实性，再逐条验证 Merkle 路径到同一根，最后根据已验证的位值重算判定并与 Server 声明比对。

**安全性质**：正确性（Correctness）——诚实执行下验证通过且输出与 Nomos 资格语义一致；绑定健全性（Binding-Soundness）——对手使 Client 接受"声明判定与承诺状态不一致"的响应的概率可忽略，归约到 CRHF 与签名 EUF-CMA；新鲜性（Freshness）——对手使 Client 接受旧版本或混合版本证明的概率可忽略，由版本锚点签名保证。

**能力边界**：QTree 保证"位值真实性"（bit value authenticity），即 Server 不能伪造任何地址上的位值。但其验证前提是 Client 知道哪些地址应该被验证——而在 Nomos 的 OPRF 盲化设计下，Client 不持有 $K_X$，无法自行计算物理地址。这一缺口构成第三章的研究动机。

#### 创新点二：基于嵌入式承诺的地址绑定验证机制（第三章）

**问题定位——位置盲化**：在 Nomos 中，$(w, \mathsf{id})$ 对应的 XSet 物理地址由 Server 在搜索阶段通过 $\alpha$ 参数与 $\mathsf{xtoken}$ 计算得到。Client 不持有 $K_X$，只知道令牌的盲化形式，不知道最终的物理地址。这是 Nomos 隐私设计的固有特征——它保证 Client 不获知查询的物理访问模式——但同时导致 Client 无法判断 Server 返回的 Merkle Proof 是否对应正确的地址。

**攻击模型——地址替换攻击**：Server 收到令牌后计算出 $\mathsf{id}$ 对应的真实地址集合 $\{\mathsf{Addr}_1, \ldots, \mathsf{Addr}_k\}$，这些地址上的位值全为 1（$\mathsf{id}$ 应通过资格检验）。Server 找到一个不属于该集合但位值为 0 的地址（如地址 999），返回该地址的合法 Merkle Proof，声称 $\mathsf{id}$ 不通过。Client 验证 Merkle Proof 有效——因为地址 999 确实在 QTree 中且位值确实为 0——从而错误地接受了"$\mathsf{id}$ 不通过"的判定。攻击的本质是：Server 用"张冠李戴"的证据欺骗 Client，Merkle Proof 本身合法，但证明的地址不是 $\mathsf{id}$ 对应的地址。

**机制设计——嵌入式承诺**：GK 在 Update 阶段拥有所有密钥，能计算 $(w, \mathsf{id})$ 对应的全部 $\ell$ 个 XSet 地址 $\{\mathsf{xtag}_1, \ldots, \mathsf{xtag}_\ell\}$。GK 计算地址承诺 $Cm = H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell)$（地址按确定性排序），将 $Cm$ 嵌入 TSet 认证加密 Payload（$\mathsf{AE.Enc}$），使其在 Update 阶段即确定且与后续查询无关。承诺粒度为 per-$(w, \mathsf{id})$，每条 TSet 记录嵌入该记录对应的 $\ell$ 个 XSet 地址的承诺。

**验证流程**：Search 阶段，Server 返回加密 Payload（含 $Cm$）与全部 $\ell$ 个地址作为开封信息。Verify 阶段，Client 解密 Payload 得到 $Cm$，验证 $H(\mathsf{xtag}_1 \| \cdots \| \mathsf{xtag}_\ell) = Cm$，确认地址集合与 GK 在更新阶段确定的一致；然后检查 Server 实际使用的 $k$ 个采样地址是否为 $\ell$ 个地址中由 $\{\beta_i\}$ 索引的子集；最后结合 Merkle 路径验证位值。

**安全性质**：地址绑定健全性（Address Binding Soundness）——对任意 PPT 对手 $\mathcal{A}$，其使 Client 接受一个"证明地址不属于承诺地址集合"的响应的概率 $\Pr[\mathsf{Verify} = 1 \wedge \exists a \in \mathsf{Proof}: a \notin \{\mathsf{xtag}_1, \ldots, \mathsf{xtag}_\ell\}] \leq \mathsf{negl}(\lambda)$。归约：若 Server 能构造一组地址 $\{\mathsf{xtag}'_1, \ldots, \mathsf{xtag}'_\ell\}$ 使得 $H(\mathsf{xtag}'_1 \| \cdots \| \mathsf{xtag}'_\ell) = Cm$ 但 $\{\mathsf{xtag}'_i\} \neq \{\mathsf{xtag}_i\}$，则构成 $H$ 的碰撞，归约到 CRHF。

**开销特征**：存储方面，每条 TSet 记录增加一个 $\lambda$ 比特的承诺值，总额外存储 $O(N \cdot \lambda)$；通信方面，每个候选的开封信息为 $\ell$ 个地址，额外通信 $O(|\mathsf{Cand}(w_s)| \cdot \ell \cdot \lambda)$；计算方面，Client 每个候选执行一次哈希验证与子集归属检查，额外计算 $O(|\mathsf{Cand}(w_s)| \cdot \ell)$。

#### 两个创新点的组合关系

第二章 QTree 提供"位值真实性"——Server 不能伪造任何地址上的位值；第三章嵌入式承诺提供"地址正确性"——Server 不能将不属于目标 $\mathsf{id}$ 的地址替换进验证流程。两者组合构成完整的可验证资格检验：Server 在正确的地址上给出真实的位值，Client 据此重算判定，任何偏离协议的行为均可被检测。组合安全性归约到 CRHF + 签名 EUF-CMA + AE INT-CTXT。
### 安全证明强化方案：基于游戏的形式化定义与游戏跳跃证明

  #### 一、现状诊断

  当前 bf.tex 的安全分析（定义 1-4、命题 1-4）与 commitment.tex 的安全分析（定义 5、命题 5-6）均为"性质声明 + 归约思路概述"形式，存在以下不足：

  1. 安全定义未给出完整的 Challenger-Adversary 交互实验，缺少预言机接口、状态维护与胜利条件的形式化描述。
  2. 证明为自然语言概述，未使用游戏跳跃（game hopping）技术逐步消除对手优势，缺少显式的优势不等式链。
  3. 未给出具体的优势界，仅以 $\mathsf{negl}(\lambda)$ 笼统概括。
  4. 归约算法未显式构造——未说明如何从可验证性对手 $\mathcal{A}$ 构造 CRHF 碰撞发现者 $\mathcal{B}_1$ 或签名伪造者 $\mathcal{B}_2$。

  #### 二、目标

  将定义 1-5 与命题 1-6 全部升级为基于游戏的形式化版本，证明采用游戏跳跃序列，给出显式优势界与归约算法构造。

  #### 三、第二章安全游戏与证明设计

  ##### 3.1 安全实验 $\mathsf{Exp}_{\Pi,\mathcal{A}}^{\mathsf{VQ\text{-}Sound}}(\lambda)$（绑定健全性）

  实验 Exp^{VQ-Sound}_{Π,A}(λ):
  1. Challenger C 运行 Setup(1^λ) → (K, st, EDB)，初始化 QTree，
  维护签名密钥 sk_G 与已签名锚点集合 S_anchor = ∅
  2. C 将 EDB 发送给 A
  3. A 可自适应发起以下预言机查询：
    - O_Update(w, id, op)：C 按协议执行 Update，更新 QTree，
  生成新锚点 (t, R_X^{(t)}, σ_t)，将 (t||R_X^{(t)}) 加入 S_anchor，
  将更新消息发送给 A
    - O_GenToken(Q, C_i)：C 按协议执行 GenToken，返回令牌 τ 给 A
    - O_Anchor：C 返回当前最新锚点 (t, R_X^{(t)}, σ_t)
  4. A 输出目标查询 Q* 与响应 ρ*
  5. C 运行 VQ-Verify(K, st, τ*, ρ*) → (acc, Res')
  6. A 胜利当且仅当：
  acc = 1 ∧ ∃(j, id) ∈ R(Q*): v̂_{j,id} ≠ v_{j,id}^{(t,ν)}

  优势定义：$\mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{VQ\text{-}Sound}}(\lambda) = \Pr[\mathsf{Exp}_{\Pi,\mathcal{A}}^{\mathsf{VQ\text{-}Sound}}(\lambda) = 1]$

  ##### 3.2 游戏跳跃序列

  **Game $G_0$**：即实验 $\mathsf{Exp}^{\mathsf{VQ\text{-}Sound}}$，$\mathcal{A}$ 的胜利概率为 $p_0 = \mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{VQ\text{-}Sound}}(\lambda)$。

  **Game $G_1$**（消除签名伪造）：与 $G_0$ 相同，但增加中止规则——若 $\mathcal{A}$ 在 $\rho^*$ 中提供的锚点 $(t', R')$ 满足 $\mathsf{VfSig}(\mathsf{pk}_G, t'\|R', \sigma') = 1$ 但
   $(t'\|R') \notin S_{\mathsf{anchor}}$，则实验中止并判 $\mathcal{A}$ 失败。

  过渡论证：构造归约算法 $\mathcal{B}_1$，$\mathcal{B}_1$ 模拟 $G_0$ 的全部交互，当中止事件 $E_1$ 发生时输出 $(t'\|R', \sigma')$ 作为 EUF-CMA 伪造。因此 $|p_0 - p_1| \leq
  \mathsf{Adv}_{\mathsf{Sig},\mathcal{B}_1}^{\mathsf{EUF\text{-}CMA}}(\lambda)$。

  **Game $G_2$**（消除 Merkle 路径伪造）：与 $G_1$ 相同，但增加中止规则——若 $\mathcal{A}$ 提供的某个证明三元组 $(a, b, \pi_a)$ 满足 $\mathsf{VfPath}(R_X^{(t)}, a, b, \pi_a) = 1$
  但 $B^{(t)}[a] \neq b$，则实验中止。

  过渡论证：构造归约算法 $\mathcal{B}_2$，$\mathcal{B}_2$ 模拟 $G_1$ 的全部交互，当中止事件 $E_2$ 发生时从伪造路径中提取 $H$ 的碰撞对。具体地，设真实叶节点为 $L_a =
  H(0\|a\|B^{(t)}[a])$，伪造叶节点为 $L'_a = H(0\|a\|b)$，其中 $b \neq B^{(t)}[a]$。若 $L_a = L'_a$ 则直接得到碰撞；否则沿路径向上追溯，必存在某层内部节点产生碰撞。因此 $|p_1 -
  p_2| \leq \mathsf{Adv}_{H,\mathcal{B}_2}^{\mathsf{CR}}(\lambda)$。

  **Game $G_2$ 中 $\mathcal{A}$ 的胜利概率**：在 $G_2$ 中，锚点未被伪造（$G_1$ 保证），路径未被伪造（$G_2$ 保证），因此 Client 验证得到的每个位值 $b$ 均等于 $B^{(t)}[a]$。Client
  据此重算判定位 $v'_{j,\mathsf{id}} = \bigwedge_{a \in \mathcal{A}_{j,\mathsf{id}}^{(t,\nu)}} B^{(t)}[a] = v_{j,\mathsf{id}}^{(t,\nu)}$，与真实判定一致。因此 $p_2 = 0$。

  **最终优势界**：

  $$\mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{VQ\text{-}Sound}}(\lambda) \leq \mathsf{Adv}_{\mathsf{Sig},\mathcal{B}_1}^{\mathsf{EUF\text{-}CMA}}(\lambda) +
  \mathsf{Adv}_{H,\mathcal{B}_2}^{\mathsf{CR}}(\lambda)$$

  ##### 3.3 新鲜性实验 $\mathsf{Exp}^{\mathsf{Fresh}}$（简化处理）

  新鲜性可作为绑定健全性的推论：在 $G_1$ 中已排除签名伪造，因此 $\mathcal{A}$ 无法构造通过验签的旧版本或混合版本锚点。Client 的版本不回退检查 $t \geq t^*$
  进一步排除合法但过期的锚点重放。新鲜性不需要独立的游戏跳跃序列，可在绑定健全性证明中作为 $G_1$ 的直接推论给出。

  #### 四、第三章安全游戏与证明设计

  ##### 4.1 安全实验 $\mathsf{Exp}_{\Pi,\mathcal{A}}^{\mathsf{AB\text{-}Sound}}(\lambda)$（地址绑定健全性）

  实验 Exp^{AB-Sound}_{Π,A}(λ):
  1. Challenger C 运行 Setup(1^λ)，维护每条 TSet 记录的
  明文承诺表 T_cm[(w,id)] = Cm_{w,id} 与完整标签表
  T_xtag[(w,id)] = (xtag_1,...,xtag_ℓ)
  2. C 将 EDB 发送给 A
  3. A 可自适应发起 O_Update、O_GenToken 查询（同上）
  4. A 输出目标查询 Q* 与响应 ρ'*
  5. C 运行 Verify'(K, st, τ*, ρ'*) → (acc, Res')
  6. A 胜利当且仅当：
  acc = 1 ∧ ∃(j, id) ∈ R(Q*):
    Open_{j,id} 中存在某地址 a ∉ F_{w_j,id}
    （即开封材料包含不属于 GK 确定的完整标签集合的地址）

  优势定义：$\mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{AB\text{-}Sound}}(\lambda) = \Pr[\mathsf{Exp}_{\Pi,\mathcal{A}}^{\mathsf{AB\text{-}Sound}}(\lambda) = 1]$

  ##### 4.2 游戏跳跃序列

  **Game $G_0$**：即实验 $\mathsf{Exp}^{\mathsf{AB\text{-}Sound}}$，胜利概率 $p_0$。

  **Game $G_1$**（消除 TSet 载荷篡改）：与 $G_0$ 相同，但增加中止规则——若 $\mathcal{A}$ 返回的 TSet 密文经 $\mathsf{AE.Dec}$ 解密后得到的 $\mathsf{Cm}'_{w_j,\mathsf{id}} \neq
  T_{\mathsf{cm}}[(w_j,\mathsf{id})]$（即承诺值被篡改），或 $\mathsf{AE.Dec}$ 输出 $\bot$（即密文完整性校验失败），则实验中止。

  过渡论证：TSet 载荷由 PRF 派生会话密钥 $K_E(w,\mathsf{cnt})$ 进行认证加密（$\mathsf{AE.Enc}$）。$\mathcal{A}$ 不持有 $K_T$，无法计算 $K_E$。构造归约算法 $\mathcal{B}_1$：$\mathcal{B}_1$ 持有 $\mathsf{AE}$ 的加密预言机（但不持有密钥），在 $O_{\mathsf{Update}}$ 中调用加密预言机生成 $\mathsf{val}'$。若 $\mathcal{A}$ 能构造不同于 $\mathcal{G}$ 生成的密文 $\mathsf{val}'^*$ 且 $\mathsf{AE.Dec}_{K_E}(\mathsf{val}'^*)\neq\bot$，则 $\mathcal{B}_1$ 输出 $\mathsf{val}'^*$ 作为 INT-CTXT 伪造。因此 $|p_0 - p_1| \leq
  \mathsf{Adv}_{\mathsf{AE},\mathcal{B}_1}^{\mathsf{INT\text{-}CTXT}}(\lambda)$。

  注：此处的归约目标为认证加密的 INT-CTXT（密文完整性），而非 IND-CPA 或 PRF 安全性。原因在于 TSet 载荷加密已从流密码（XOR with PRF）升级为认证加密（$\mathsf{AE.Enc}$）。流密码仅提供机密性，不提供完整性——恶意服务器在更新阶段接收明文 $\mathsf{xtag}$，可自行计算 $\mathsf{Cm}$，进而对密文中的 $\mathsf{Cm}$ 字段实施定向 XOR 篡改。认证加密的 INT-CTXT 性质确保任何密文篡改均导致解密失败。

  **Game $G_2$**（消除承诺碰撞）：与 $G_1$ 相同，但增加中止规则——若 $\mathcal{A}$ 提供的开封材料 $(\mathsf{xtag}'_1, \ldots, \mathsf{xtag}'_\ell)$ 满足
  $H_c(\mathsf{xtag}'_1\|\cdots\|\mathsf{xtag}'_\ell) = \mathsf{Cm}_{w_j,\mathsf{id}}$ 但 $(\mathsf{xtag}'_1, \ldots, \mathsf{xtag}'_\ell) \neq (\mathsf{xtag}_1, \ldots,
  \mathsf{xtag}_\ell)$，则实验中止。

  过渡论证：构造归约算法 $\mathcal{B}_2$，当中止事件发生时输出 $((\mathsf{xtag}'_1\|\cdots\|\mathsf{xtag}'_\ell),\; (\mathsf{xtag}_1\|\cdots\|\mathsf{xtag}_\ell))$ 作为 $H_c$
  的碰撞对。因此 $|p_1 - p_2| \leq \mathsf{Adv}_{H_c,\mathcal{B}_2}^{\mathsf{CR}}(\lambda)$。

  **Game $G_2$ 中 $\mathcal{A}$ 的胜利概率**：在 $G_2$ 中，$\mathsf{Cm}$ 未被篡改（$G_1$ 保证），开封材料与原始标签集合一致（$G_2$ 保证），因此 $\mathsf{Open}_{j,\mathsf{id}}$
  中的全部 $\ell$ 个地址均属于 $\mathcal{F}_{w_j,\mathsf{id}}$。Client 的子集归属检查确认 $k$ 个证明地址从 $\ell$ 个承诺地址中按 $\{\beta_i\}$
  索引选取，因此证明地址全部正确。$p_2 = 0$。

  **最终优势界**：

  $$\mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{AB\text{-}Sound}}(\lambda) \leq \mathsf{Adv}_{\mathsf{AE},\mathcal{B}_1}^{\mathsf{INT\text{-}CTXT}}(\lambda) +
  \mathsf{Adv}_{H_c,\mathcal{B}_2}^{\mathsf{CR}}(\lambda)$$

  #### 五、组合安全性游戏与证明设计

  ##### 5.1 安全实验 $\mathsf{Exp}_{\Pi,\mathcal{A}}^{\mathsf{CV}}(\lambda)$（组合可验证性）

  实验 Exp^{CV}{Π,A}(λ):
  1-4. 同 Exp^{VQ-Sound}，但 Verify 使用扩展验证流程 Verify'
       （含四层验证：版本校验、承诺开封、地址归属与路径验证、语义校验）
  5. A 胜利当且仅当：
     Verify'(ρ'*) = Accept ∧ ∃(j, id): v̂{j,id} ≠ v_{j,id}^{(t,ν)}

  ##### 5.2 四步游戏跳跃序列

  **Game $G_0$**：实验 $\mathsf{Exp}^{\mathsf{CV}}$，胜利概率 $p_0$。

  **Game $G_1$**（消除签名伪造）：中止条件同第二章 $G_1$。
  $|p_0 - p_1| \leq \mathsf{Adv}_{\mathsf{Sig},\mathcal{B}_1}^{\mathsf{EUF\text{-}CMA}}(\lambda)$

  **Game $G_2$**（消除 TSet 载荷篡改）：中止条件同第三章 $G_1$。
  $|p_1 - p_2| \leq \mathsf{Adv}_{\mathsf{AE},\mathcal{B}_2}^{\mathsf{INT\text{-}CTXT}}(\lambda)$

  **Game $G_3$**（消除承诺碰撞）：中止条件同第三章 $G_2$。
  $|p_2 - p_3| \leq \mathsf{Adv}_{H_c,\mathcal{B}_3}^{\mathsf{CR}}(\lambda)$

  **Game $G_4$**（消除 Merkle 路径伪造）：中止条件同第二章 $G_2$。
  $|p_3 - p_4| \leq \mathsf{Adv}_{H,\mathcal{B}_4}^{\mathsf{CR}}(\lambda)$

  **$G_4$ 中胜利概率**：签名有效且新鲜 → 根哈希正确。$\mathsf{Cm}$ 未篡改 → 承诺为 GK 原始值。开封无碰撞 → 地址为 GK 原始集合。路径无伪造 → 位值真实。Client
  在正确地址上据真实位值重算判定 → 判定正确。$p_4 = 0$。

  **最终优势界**：

  $$\mathsf{Adv}_{\Pi,\mathcal{A}}^{\mathsf{CV}}(\lambda) \leq \mathsf{Adv}_{\mathsf{Sig}}^{\mathsf{EUF\text{-}CMA}} + \mathsf{Adv}_{\mathsf{AE}}^{\mathsf{INT\text{-}CTXT}} +
  \mathsf{Adv}_{H_c}^{\mathsf{CR}} + \mathsf{Adv}_{H}^{\mathsf{CR}}$$

  #### 六、写入 LaTeX 的执行计划

  1. **bf.tex 改造**：
     - 将定义 2 改写为完整的安全实验 $\mathsf{Exp}^{\mathsf{VQ\text{-}Sound}}$，含 Challenger 伪代码
     - 将命题 2 的证明替换为 $G_0 \to G_1 \to G_2$ 三步游戏跳跃，每步给出归约算法 $\mathcal{B}_i$ 的构造描述与优势不等式
     - 新鲜性（命题 3）作为 $G_1$ 的推论处理，不需独立游戏序列
     - 条件完整性（命题 4）保持当前结构，补充显式优势界

  2. **commitment.tex 改造**：
     - 将定义 5 改写为完整的安全实验 $\mathsf{Exp}^{\mathsf{AB\text{-}Sound}}$
     - 将命题 5 的证明替换为 $G_0 \to G_1 \to G_2$ 三步游戏跳跃
     - 将命题 6 的证明替换为 $G_0 \to G_1 \to G_2 \to G_3 \to G_4$ 四步游戏跳跃
     - 注意：命题 5 中 $G_1$ 的归约目标为 INT-CTXT（匹配 TSet 载荷的认证加密结构）

  3. **符号一致性检查**：
     - 确认 $\mathsf{Adv}$ 上标格式统一（$\mathsf{VQ\text{-}Sound}$、$\mathsf{AB\text{-}Sound}$、$\mathsf{CV}$）
     - 确认归约算法编号 $\mathcal{B}_1, \mathcal{B}_2, \ldots$ 在各章独立计数
     - 确认游戏编号 $G_0, G_1, \ldots$ 在各命题证明中独立计数

  ---
  内容二：VSSE 方案系统性对比

  建议插入位置：紧接上一节之后，"研究方法论"之前。

  ### 已有 VSSE 方案系统性对比

  #### 一、对比目的

  审稿人的核心质疑是："已有 VSSE 方案能否通过简单修改适配 Nomos？"本节通过系统性对比回答该问题，明确本文方案在 Nomos 特有架构下的不可替代性。

  #### 二、已有 VSSE 方案分类与技术特征

  ##### 2.1 基于 MAC 的方案

  **代表工作**：Kurosawa & Ohtaki (FC 2012, CANS 2013)、Ogata & Kurosawa (FC 2017)

  - 验证技术：对每个 (keyword, document) 对计算 MAC 标签，Client 持有验证密钥，搜索结果附带 MAC 标签供 Client 校验
  - 验证范围：结果正确性（返回的文件确实匹配查询关键词）
  - 安全模型：UC 安全（模拟范式），非游戏范式
  - 查询类型：单关键词
  - 客户端模型：单客户端
  - 动态支持：Kurosawa 2013 支持动态更新
  - 泄露函数：标准 SSE 泄露（搜索模式 + 访问模式）
  - 渐近开销：存储 $O(N \cdot \lambda)$，通信 $O(|\mathsf{Res}| \cdot \lambda)$，计算 $O(|\mathsf{Res}|)$
  - 局限性：MAC 标签绑定在 (keyword, document) 粒度，无法验证 XSet 位级操作；单客户端模型下 Client 持有 MAC 密钥，不适用于多客户端 OPRF 架构

  ##### 2.2 基于累加器的方案

  **代表工作**：Chai & Gong (ICC 2012)

  - 验证技术：RSA 累加器对结果集构建成员证明
  - 验证范围：结果正确性 + 完整性
  - 安全模型：游戏范式（Strong RSA 假设）
  - 查询类型：单关键词
  - 客户端模型：单客户端
  - 动态支持：静态
  - 泄露函数：标准 SSE 泄露
  - 渐近开销：存储 $O(N)$（累加器值），通信 $O(|\mathsf{Res}| \cdot \lambda)$，计算 $O(|\mathsf{Res}| \cdot \lambda)$（模幂运算）
  - 局限性：累加器验证的是最终结果集的成员性，不涉及中间步骤（资格检验）的正确性；RSA 累加器的模幂运算开销在大候选集下显著

  ##### 2.3 基于 MHT 的方案

  **代表工作**：Sun et al. (INFOCOM 2015)

  - 验证技术：在结果集上构建 MHT，Server 返回认证路径
  - 验证范围：结果正确性 + 完整性（合取查询）
  - 安全模型：游戏范式（CRHF 假设）
  - 查询类型：合取查询
  - 客户端模型：单客户端
  - 动态支持：动态
  - 泄露函数：标准 SSE 泄露 + 结果集 MHT 根
  - 渐近开销：存储 $O(N \cdot \log N)$，通信 $O(|\mathsf{Res}| \cdot \log N)$，计算 $O(|\mathsf{Res}| \cdot \log N)$
  - 局限性：MHT 构建在结果集上（验证"返回了哪些文件"），而非 XSet 位数组上（验证"资格检验过程是否正确"）；单客户端模型，不面临 OPRF 盲化下的地址替换问题

  ##### 2.4 基于 iO 的方案

  **代表工作**：Cheng et al. (CCS 2015)

  - 验证技术：不可区分混淆（iO）构造验证电路
  - 验证范围：结果正确性（理论最强保证）
  - 安全模型：模拟范式（iO + 单向函数）
  - 查询类型：单关键词
  - 客户端模型：单客户端
  - 动态支持：静态
  - 泄露函数：最小泄露
  - 渐近开销：$O(\mathsf{poly}(\lambda))$，实际不可部署
  - 局限性：iO 的计算开销使方案仅具理论意义

  ##### 2.5 多用户 VSSE 方案

  **代表工作**：Liu et al. (TDSC 2020)

  - 验证技术：MAC + 签名（Server 对结果签名，Client 验签）
  - 验证范围：结果正确性
  - 安全模型：游戏范式
  - 查询类型：单关键词
  - 客户端模型：多客户端
  - 动态支持：动态
  - 泄露函数：标准 SSE 泄露 + 令牌可链接性
  - 渐近开销：存储 $O(N \cdot \lambda)$，通信 $O(|\mathsf{Res}| \cdot \lambda)$，计算 $O(|\mathsf{Res}|)$
  - 局限性：仅支持单关键词查询，不涉及合取查询中的交叉标签资格检验步骤

  ##### 2.6 前向安全 VSSE 方案

  **代表工作**：Zhang et al. (ESORICS 2019)

  - 验证技术：MAC + 链式哈希（每次更新链接前一状态的哈希）
  - 验证范围：结果正确性 + 新鲜性
  - 安全模型：游戏范式
  - 查询类型：单关键词
  - 客户端模型：单客户端
  - 动态支持：动态 + 前向安全
  - 泄露函数：前向安全泄露（更新不泄露关键词身份）
  - 渐近开销：存储 $O(N \cdot \lambda)$，通信 $O(|\mathsf{Res}| \cdot \lambda)$，计算 $O(|\mathsf{Res}|)$
  - 局限性：同上，单关键词、不涉及资格检验

 #### 三、对比总表                                                                                                                                                               
                                                            
  | 维度 | Kurosawa 2012/2013 | Chai 2012 | Sun 2015 | Cheng 2015 | Liu 2020 | Zhang 2019 | 本文 |                                                                                
  |------|-------------------|-----------|----------|------------|----------|------------|------|
  | 验证技术 | MAC | RSA 累加器 | MHT（结果集） | iO | MAC+签名 | MAC+链哈希 | MHT（XSet 位数组）+ 嵌入式承诺 |
  | 验证目标 | 结果正确性 | 结果正确性+完整性 | 结果正确性+完整性 | 结果正确性 | 结果正确性 | 结果正确性+新鲜性 | 资格检验正确性（位值真实性+地址正确性） |
  | 查询类型 | 单关键词 | 单关键词 | 合取 | 单关键词 | 单关键词 | 单关键词 | 合取 |
  | 客户端模型 | 单客户端 | 单客户端 | 单客户端 | 单客户端 | 多客户端 | 单客户端 | 多客户端 |
  | 动态支持 | 2013 版支持 | 否 | 是 | 否 | 是 | 是 | 是 |
  | 安全模型 | UC | 游戏范式 | 游戏范式 | 模拟范式 | 游戏范式 | 游戏范式 | 游戏范式（游戏跳跃） |
  | 密码学假设 | PRF | Strong RSA | CRHF | iO+OWF | PRF+EUF-CMA | PRF | CRHF+EUF-CMA+INT-CTXT |
  | 存储开销 | $O(N\lambda)$ | $O(N)$ | $O(N\log N)$ | $O(N\cdot\mathsf{poly}(\lambda))$ | $O(N\lambda)$ | $O(N\lambda)$ | $O(N(\lambda + \ell\log M))$ |
  | 通信开销 | $O(|\mathsf{Res}|\lambda)$ | $O(|\mathsf{Res}|\lambda)$ | $O(|\mathsf{Res}|\log N)$ | 不可部署 | $O(|\mathsf{Res}|\lambda)$ | $O(|\mathsf{Res}|\lambda)$ |
  $O(|\mathsf{Cand}|(n{-}1)(k\log M + \ell|\mathbb{G}|))$ |
  | 计算开销（Client） | $O(|\mathsf{Res}|)$ | $O(|\mathsf{Res}|\lambda)$ | $O(|\mathsf{Res}|\log N)$ | 不可部署 | $O(|\mathsf{Res}|)$ | $O(|\mathsf{Res}|)$ |
  $O(|\mathsf{Cand}|(n{-}1)(k\log M + \ell))$ |
  | OPRF 盲化兼容 | 否 | 否 | 否 | 否 | 否 | 否 | 是 |

  #### 四、不可替代性论证

  本节回答审稿人的核心质疑："已有 VSSE 方案能否通过简单修改适配 Nomos？"

  ##### 4.1 MAC 方案不适用的根本原因

  MAC 方案（Kurosawa 2012/2013、Ogata 2017、Zhang 2019）的验证粒度为 (keyword, document) 对——对每个匹配结果附带一个 MAC 标签，Client
  验证标签即可确认该结果确实匹配查询关键词。该机制验证的是最终结果的正确性，而非中间步骤的执行正确性。

  在 Nomos/OXT 架构中，资格检验是一个位级操作：Server 在 XSet 位数组上查询 $k$ 个地址的位值，据此判定候选是否通过。MAC 标签无法绑定到"Server
  在哪些地址上查询了什么位值"这一中间过程。即使为每个 XSet 位地址预计算 MAC 标签，Client 仍面临地址替换问题——在 OPRF 盲化下 Client 不知道应验证哪些地址的 MAC。

  此外，MAC 方案要求 Client 持有 MAC 验证密钥。在 Nomos 的多客户端模型中，Client 不持有系统主密钥 $K_X$，MAC 密钥的分发将破坏 Nomos 的密钥隔离设计。

  ##### 4.2 累加器方案不适用的根本原因

  累加器方案（Chai 2012）验证的是"结果集的成员性"——某个文件标识确实属于查询结果集。该验证发生在搜索流程的最终输出阶段。

  Nomos 的资格检验发生在搜索流程的中间阶段：Server 枚举候选集合后，对每个候选逐一执行 XSet
  成员测试以过滤不满足交叉关键词条件的候选。累加器无法验证这一过滤过程的正确性——它只能验证最终通过过滤的结果是否"确实在某个集合中"，但无法验证"被过滤掉的候选是否应该被过滤"。

  更根本地，RBF 的成员测试是概率性的（$\ell$ 次插入、$k$ 次采样），不是标准的集合成员关系，无法直接映射到累加器的成员证明语义。

  ##### 4.3 Sun 2015 MHT 方案的差异

  Sun et al. (2015) 是已有工作中与本文最接近的方案——同样使用 MHT，同样支持合取查询。关键差异在于 MHT 的构建对象与验证目标：

  - Sun 2015：MHT 构建在结果集上，验证"Server 返回的结果集是否完整且正确"
  - 本文：MHT 构建在 XSet 位数组上，验证"Server 在资格检验过程中声称的位值是否真实"

  Sun 2015 的 MHT 根由 Client 在初始化阶段计算并本地存储，搜索时 Server 返回结果集的 Merkle 路径。该方案假设 Client 持有完整密钥（单客户端模型），能够自行确定结果集的预期内容。

  在 Nomos 的多客户端 OPRF 架构下，Client 不持有 $K_X$，无法预计算结果集的 MHT 根，也无法自行确定 XSet 中的物理地址。Sun 2015 的方案无法直接移植到 Nomos——即使将 MHT 从结果集改为
  XSet 位数组，仍然面临地址替换攻击（本文第三章解决的问题）。

  ##### 4.4 Liu 2020 多用户方案的差异

  Liu et al. (2020) 是已有工作中唯一的多客户端 VSSE 方案。但该方案仅支持单关键词查询，不涉及合取查询中的交叉标签资格检验步骤。其验证机制为 Server 对结果签名、Client
  验签，本质上是结果级验证，不覆盖 XSet 位级操作。

  ##### 4.5 本文方案的独特定位

  综合以上分析，本文方案的不可替代性来自三个维度的交叉：

  1. **验证目标的独特性**：验证资格检验过程（中间步骤），而非最终结果（输出阶段）。已有 VSSE 方案均验证最终结果，不覆盖 OXT/Nomos 架构中的 XSet 交叉标签成员测试步骤。

  2. **OPRF 盲化下的地址绑定**：在 Client 不知道物理地址的前提下建立地址正确性保证。已有方案均假设 Client 持有完整密钥或能自行确定验证目标，不面临位置盲化问题。

  3. **多客户端合取查询的组合**：同时满足多客户端模型与合取查询支持。已有方案要么是多客户端但仅支持单关键词（Liu 2020），要么支持合取查询但仅限单客户端（Sun 2015）。

  #### 五、需补充的参考文献

  当前 thesis.bib 中已有 8 篇 VSSE 相关文献。为支撑对比分析，需补充以下条目：

  1. Kurosawa & Ohtaki, "UC-Secure Searchable Symmetric Encryption", FC 2012（UC-SSE 原始论文）
  2. Kamara, Papamanthou & Roeder, "Dynamic Searchable Symmetric Encryption", CCS 2012（DSSE 安全游戏定义的标准参考）
  3. Papamanthou, Tamassia & Triandopoulos, "Authenticated Hash Tables Based on Cryptographic Accumulators", 2011（认证数据结构基础）
  4. Tamassia, "Authenticated Data Structures", ESA 2003（ADS 经典综述）
  5. Catalano & Fiore, "Vector Commitments and Their Applications", PKC 2013（向量承诺，与嵌入式承诺技术相关）

  #### 六、写入 LaTeX 的执行计划

  1. **绪论（intro.tex）**：在"国内外研究现状"节中增加 VSSE 专题段落，按验证技术分类综述已有工作，明确指出"已有 VSSE 方案均验证最终结果，不覆盖资格检验中间步骤"的研究空白。

  2. **第二章（bf.tex）**：在"设计动机与问题分析"节中增加一段，简要说明 MAC/累加器方案不适用于 XSet 位级验证的原因，引出 MHT 作为替代方案的动机。

  3. **第三章（commitment.tex）**：在"基线能力边界与位置盲化问题"节中增加一段，说明 Sun 2015 的 MHT 方案在 OPRF 盲化下不可直接移植，引出嵌入式承诺的必要性。

  4. **对比表**：以 LaTeX tabular
  形式放入第二章或第三章的安全性分析节末尾，或放入第四章实验评估节作为安全特性对比（与性能对比并列）。建议放入第二章末尾，因为对比的核心维度是安全性质而非性能。

  ---
  以上就是两个完整章节的全部内容。总结一下结构：

  - 安全证明强化方案：为第二章设计了 $G_0 \to G_1 \to G_2$ 三步游戏跳跃（消除签名伪造 → 消除路径伪造 → 胜利概率为零），为第三章设计了 $G_0 \to G_1 \to G_2$ 三步（消除载荷篡改 →
  消除承诺碰撞），为组合安全性设计了 $G_0 \to G_1 \to G_2 \to G_3 \to G_4$ 四步。每步均给出归约算法构造与显式优势界。
  - VSSE 对比方案：覆盖 6 类已有方案，从 10 个维度对比，并逐一论证 MAC/累加器/Sun MHT/Liu 多用户方案均无法直接适配 Nomos，明确本文方案的不可替代性来自"验证目标独特性 × OPRF
  地址绑定 × 多客户端合取查询"三维交叉。
---

## 研究方法论

### 理论分析与模型构建

1. **建立系统模型**：定义系统实体、交互流程与威胁假设
2. **安全模型设计**：明确隐私对抗与正确性对抗的边界
3. **符号体系建立**：为整个研究建立统一的数学表示

### 算法设计与优化

1. **资格检验机制设计**：基于默克尔哈希树的可验证资格检验
2. **搜索结果验证设计**：基于嵌入式承诺的搜索结果正确性验证
3. **效率优化**：在保证安全性的前提下优化算法效率

### 安全性与可验证性分析

1. **正确性分析**：证明当服务器诚实执行时，资格检验结果与搜索结果的正确性
2. **可验证性分析**：证明 MHT 认证路径机制满足完整性与健全性要求
3. **隐私性讨论**：分析引入 MHT 后的泄露变化

### 实验评估

1. **性能测试**：评估引入验证机制后的搜索效率
2. **可扩展性测试**：测试在大规模数据集下的表现
3. **对比分析**：与现有方案进行性能与安全特性对比

---

## 论文结构

### 章节安排

1. **第一章：绪论**
   - 研究背景与意义
   - 国内外研究现状
   - 研究目标与内容
   - 论文结构

2. **第二章：可验证资格检验机制**
   - 系统与威胁模型
   - SSE 基础方案与局限性分析
   - 默克尔哈希树原理
   - 基于 MHT 的可验证资格检验机制
   - 安全性与可验证性分析

3. **第三章：基于嵌入式承诺的地址绑定验证**
   - 位置盲化问题与地址替换攻击分析
   - 嵌入式承诺机制设计（承诺构造、开封验证）
   - 协议构造（Update 嵌入承诺、Search 附带开封、Verify 地址归属校验）
   - 安全性分析（地址绑定健全性归约到 CRHF）
   - 与第二章的组合：完整可验证资格检验

4. **第四章：实验评估**
   - 实验环境与配置
   - 性能评估指标
   - 实验结果与分析

5. **第五章：总结与展望**
   - 研究总结
   - 未来研究方向

---

## 研究流程

### 阶段一：问题分析与模型构建

1. 调研国内外研究现状
2. 识别研究空白
3. 建立系统与威胁模型
4. 定义研究目标与创新点

### 阶段二：机制设计与实现

1. 设计可验证资格检验机制
2. 设计搜索结果正确性验证机制
3. 实现原型系统
4. 进行初步测试

### 阶段三：分析与优化

1. 进行安全性与可验证性分析
2. 优化算法性能
3. 完善实验设计
4. 准备论文内容

### 阶段四：实验与验证

1. 执行实验评估
2. 分析实验结果
3. 完成论文撰写
4. 准备答辩

---

**最后更新**：2026-02-25
**标签**：研究流程，论文结构，方法论
